// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const getEventById = `-- name: GetEventById :one
select id, title_en, title_pl, starts_at, ends_at, is_virtual, description_en, description_pl, event_type, base_price_amount, base_price_currency, inserted_at, updated_at, venue_id, slug from events where id = ($1::text)::uuid
`

func (q *Queries) GetEventById(ctx context.Context, id string) (*Event, error) {
	row := q.db.QueryRow(ctx, getEventById, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.TitleEn,
		&i.TitlePl,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsVirtual,
		&i.DescriptionEn,
		&i.DescriptionPl,
		&i.EventType,
		&i.BasePriceAmount,
		&i.BasePriceCurrency,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.VenueID,
		&i.Slug,
	)
	return &i, err
}

const getEventBySlug = `-- name: GetEventBySlug :one
select id, title_en, title_pl, starts_at, ends_at, is_virtual, description_en, description_pl, event_type, base_price_amount, base_price_currency, inserted_at, updated_at, venue_id, slug from events where slug = $1::text
`

func (q *Queries) GetEventBySlug(ctx context.Context, slug string) (*Event, error) {
	row := q.db.QueryRow(ctx, getEventBySlug, slug)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.TitleEn,
		&i.TitlePl,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsVirtual,
		&i.DescriptionEn,
		&i.DescriptionPl,
		&i.EventType,
		&i.BasePriceAmount,
		&i.BasePriceCurrency,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.VenueID,
		&i.Slug,
	)
	return &i, err
}

const listEvents = `-- name: ListEvents :many
select e.id, e.slug, e.title_en, e.title_pl, e.is_virtual, e.base_price_amount, e.base_price_currency,
       e.venue_id, e.event_type, e.starts_at, e.ends_at,
       v.street venue_street, v.city_en venue_city_en, v.city_pl venue_city_pl, v.country_code venue_country_code
from events e
left join venues v on e.venue_id = v.id
order by e.starts_at desc
`

type ListEventsRow struct {
	ID                pgtype.UUID      `json:"id"`
	Slug              string           `json:"slug"`
	TitleEn           string           `json:"titleEn"`
	TitlePl           string           `json:"titlePl"`
	IsVirtual         bool             `json:"isVirtual"`
	BasePriceAmount   *decimal.Decimal `json:"basePriceAmount"`
	BasePriceCurrency *string          `json:"basePriceCurrency"`
	VenueID           pgtype.UUID      `json:"venueId"`
	EventType         EventType        `json:"eventType"`
	StartsAt          pgtype.Timestamp `json:"startsAt"`
	EndsAt            pgtype.Timestamp `json:"endsAt"`
	VenueStreet       *string          `json:"venueStreet"`
	VenueCityEn       *string          `json:"venueCityEn"`
	VenueCityPl       *string          `json:"venueCityPl"`
	VenueCountryCode  *string          `json:"venueCountryCode"`
}

func (q *Queries) ListEvents(ctx context.Context) ([]*ListEventsRow, error) {
	rows, err := q.db.Query(ctx, listEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListEventsRow
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.TitleEn,
			&i.TitlePl,
			&i.IsVirtual,
			&i.BasePriceAmount,
			&i.BasePriceCurrency,
			&i.VenueID,
			&i.EventType,
			&i.StartsAt,
			&i.EndsAt,
			&i.VenueStreet,
			&i.VenueCityEn,
			&i.VenueCityPl,
			&i.VenueCountryCode,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHostsForEvents = `-- name: ListHostsForEvents :many
select eh.event_id, h.id, h.salutation, h.given_name, h.family_name, h.profile_picture_id, h.inserted_at, h.updated_at, h.country, a.object_key profile_picture_url
from hosts h
join events_hosts eh on eh.host_id = h.id
left join assets a on h.profile_picture_id = a.id
where eh.event_id = any($1::uuid[])
order by eh.host_id, eh.position
`

type ListHostsForEventsRow struct {
	EventID           pgtype.UUID      `json:"eventId"`
	ID                pgtype.UUID      `json:"id"`
	Salutation        *string          `json:"salutation"`
	GivenName         string           `json:"givenName"`
	FamilyName        string           `json:"familyName"`
	ProfilePictureID  pgtype.UUID      `json:"profilePictureId"`
	InsertedAt        pgtype.Timestamp `json:"insertedAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	Country           *string          `json:"country"`
	ProfilePictureUrl *string          `json:"profilePictureUrl"`
}

func (q *Queries) ListHostsForEvents(ctx context.Context, eventids []pgtype.UUID) ([]*ListHostsForEventsRow, error) {
	rows, err := q.db.Query(ctx, listHostsForEvents, eventids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListHostsForEventsRow
	for rows.Next() {
		var i ListHostsForEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.ID,
			&i.Salutation,
			&i.GivenName,
			&i.FamilyName,
			&i.ProfilePictureID,
			&i.InsertedAt,
			&i.UpdatedAt,
			&i.Country,
			&i.ProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPricesForEvents = `-- name: ListPricesForEvents :many
select p.id, p.event_id, p.price_type, p.rule_type, p.price_amount, p.price_currency, p.discount_code, p.priority, p.is_active, p.valid_from, p.valid_until, p.created_at, p.updated_at from event_prices p
where p.event_id = any($1::uuid[])
order by p.event_id, p.priority
`

func (q *Queries) ListPricesForEvents(ctx context.Context, eventids []pgtype.UUID) ([]*EventPrice, error) {
	rows, err := q.db.Query(ctx, listPricesForEvents, eventids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*EventPrice
	for rows.Next() {
		var i EventPrice
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.PriceType,
			&i.RuleType,
			&i.PriceAmount,
			&i.PriceCurrency,
			&i.DiscountCode,
			&i.Priority,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
