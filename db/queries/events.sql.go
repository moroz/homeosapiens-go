// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const listEvents = `-- name: ListEvents :many
select e.id, e.title_en, e.title_pl, e.starts_at, e.ends_at, e.is_virtual, e.description_en, e.description_pl, e.event_type, e.base_price_amount, e.base_price_currency, e.inserted_at, e.updated_at, e.venue_id,
v.street venue_street, v.city_en venue_city_en, v.city_pl venue_city_pl, v.country_code venue_country_code
from events e
left join venues v on e.venue_id = v.id
order by e.starts_at desc
`

type ListEventsRow struct {
	ID                pgtype.UUID      `json:"id"`
	TitleEn           string           `json:"titleEn"`
	TitlePl           string           `json:"titlePl"`
	StartsAt          pgtype.Timestamp `json:"startsAt"`
	EndsAt            pgtype.Timestamp `json:"endsAt"`
	IsVirtual         bool             `json:"isVirtual"`
	DescriptionEn     string           `json:"descriptionEn"`
	DescriptionPl     *string          `json:"descriptionPl"`
	EventType         EventType        `json:"eventType"`
	BasePriceAmount   *decimal.Decimal `json:"basePriceAmount"`
	BasePriceCurrency *string          `json:"basePriceCurrency"`
	InsertedAt        pgtype.Timestamp `json:"insertedAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	VenueID           pgtype.UUID      `json:"venueId"`
	VenueStreet       *string          `json:"venueStreet"`
	VenueCityEn       *string          `json:"venueCityEn"`
	VenueCityPl       *string          `json:"venueCityPl"`
	VenueCountryCode  *string          `json:"venueCountryCode"`
}

func (q *Queries) ListEvents(ctx context.Context) ([]*ListEventsRow, error) {
	rows, err := q.db.Query(ctx, listEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListEventsRow
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.TitleEn,
			&i.TitlePl,
			&i.StartsAt,
			&i.EndsAt,
			&i.IsVirtual,
			&i.DescriptionEn,
			&i.DescriptionPl,
			&i.EventType,
			&i.BasePriceAmount,
			&i.BasePriceCurrency,
			&i.InsertedAt,
			&i.UpdatedAt,
			&i.VenueID,
			&i.VenueStreet,
			&i.VenueCityEn,
			&i.VenueCityPl,
			&i.VenueCountryCode,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHostsForEvents = `-- name: ListHostsForEvents :many
select eh.event_id, h.id, h.salutation, h.given_name, h.family_name, h.profile_picture_id, h.inserted_at, h.updated_at, a.object_key profile_picture_url
from hosts h
join events_hosts eh on eh.host_id = h.id
left join assets a on h.profile_picture_id = a.id
where eh.event_id = any($1::uuid[])
order by eh.host_id, eh.position
`

type ListHostsForEventsRow struct {
	EventID           pgtype.UUID      `json:"eventId"`
	ID                pgtype.UUID      `json:"id"`
	Salutation        *string          `json:"salutation"`
	GivenName         string           `json:"givenName"`
	FamilyName        string           `json:"familyName"`
	ProfilePictureID  pgtype.UUID      `json:"profilePictureId"`
	InsertedAt        pgtype.Timestamp `json:"insertedAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	ProfilePictureUrl *string          `json:"profilePictureUrl"`
}

func (q *Queries) ListHostsForEvents(ctx context.Context, eventids []pgtype.UUID) ([]*ListHostsForEventsRow, error) {
	rows, err := q.db.Query(ctx, listHostsForEvents, eventids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListHostsForEventsRow
	for rows.Next() {
		var i ListHostsForEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.ID,
			&i.Salutation,
			&i.GivenName,
			&i.FamilyName,
			&i.ProfilePictureID,
			&i.InsertedAt,
			&i.UpdatedAt,
			&i.ProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPricesForEvents = `-- name: ListPricesForEvents :many
select p.id, p.event_id, p.price_type, p.rule_type, p.price_amount, p.price_currency, p.discount_code, p.priority, p.is_active, p.valid_from, p.valid_until, p.created_at, p.updated_at from event_prices p
where p.event_id = any($1::uuid[])
order by p.event_id, p.priority
`

func (q *Queries) ListPricesForEvents(ctx context.Context, eventids []pgtype.UUID) ([]*EventPrice, error) {
	rows, err := q.db.Query(ctx, listPricesForEvents, eventids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*EventPrice
	for rows.Next() {
		var i EventPrice
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.PriceType,
			&i.RuleType,
			&i.PriceAmount,
			&i.PriceCurrency,
			&i.DiscountCode,
			&i.Priority,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
