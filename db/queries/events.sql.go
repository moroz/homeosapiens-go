// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const getEventById = `-- name: GetEventById :one
select id, title_en, title_pl, starts_at, ends_at, is_virtual, description_en, description_pl, event_type, base_price_amount, base_price_currency, inserted_at, updated_at, slug, subtitle_en, subtitle_pl, venue_name_en, venue_name_pl, venue_street, venue_city_en, venue_city_pl, venue_postal_code, venue_country_code from events where id = $1
`

func (q *Queries) GetEventById(ctx context.Context, id uuid.UUID) (*Event, error) {
	row := q.db.QueryRow(ctx, getEventById, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.TitleEn,
		&i.TitlePl,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsVirtual,
		&i.DescriptionEn,
		&i.DescriptionPl,
		&i.EventType,
		&i.BasePriceAmount,
		&i.BasePriceCurrency,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.SubtitleEn,
		&i.SubtitlePl,
		&i.VenueNameEn,
		&i.VenueNamePl,
		&i.VenueStreet,
		&i.VenueCityEn,
		&i.VenueCityPl,
		&i.VenuePostalCode,
		&i.VenueCountryCode,
	)
	return &i, err
}

const getEventBySlug = `-- name: GetEventBySlug :one
select id, title_en, title_pl, starts_at, ends_at, is_virtual, description_en, description_pl, event_type, base_price_amount, base_price_currency, inserted_at, updated_at, slug, subtitle_en, subtitle_pl, venue_name_en, venue_name_pl, venue_street, venue_city_en, venue_city_pl, venue_postal_code, venue_country_code from events where slug = $1
`

func (q *Queries) GetEventBySlug(ctx context.Context, slug string) (*Event, error) {
	row := q.db.QueryRow(ctx, getEventBySlug, slug)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.TitleEn,
		&i.TitlePl,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsVirtual,
		&i.DescriptionEn,
		&i.DescriptionPl,
		&i.EventType,
		&i.BasePriceAmount,
		&i.BasePriceCurrency,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.SubtitleEn,
		&i.SubtitlePl,
		&i.VenueNameEn,
		&i.VenueNamePl,
		&i.VenueStreet,
		&i.VenueCityEn,
		&i.VenueCityPl,
		&i.VenuePostalCode,
		&i.VenueCountryCode,
	)
	return &i, err
}

const getFreeEventById = `-- name: GetFreeEventById :one
select id, title_en, title_pl, starts_at, ends_at, is_virtual, description_en, description_pl, event_type, base_price_amount, base_price_currency, inserted_at, updated_at, slug, subtitle_en, subtitle_pl, venue_name_en, venue_name_pl, venue_street, venue_city_en, venue_city_pl, venue_postal_code, venue_country_code from events where (base_price_amount is null or base_price_amount = 0) and id = $1
`

func (q *Queries) GetFreeEventById(ctx context.Context, id uuid.UUID) (*Event, error) {
	row := q.db.QueryRow(ctx, getFreeEventById, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.TitleEn,
		&i.TitlePl,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsVirtual,
		&i.DescriptionEn,
		&i.DescriptionPl,
		&i.EventType,
		&i.BasePriceAmount,
		&i.BasePriceCurrency,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.SubtitleEn,
		&i.SubtitlePl,
		&i.VenueNameEn,
		&i.VenueNamePl,
		&i.VenueStreet,
		&i.VenueCityEn,
		&i.VenueCityPl,
		&i.VenuePostalCode,
		&i.VenueCountryCode,
	)
	return &i, err
}

const getPaidEventById = `-- name: GetPaidEventById :one
select id, title_en, title_pl, starts_at, ends_at, is_virtual, description_en, description_pl, event_type, base_price_amount, base_price_currency, inserted_at, updated_at, slug, subtitle_en, subtitle_pl, venue_name_en, venue_name_pl, venue_street, venue_city_en, venue_city_pl, venue_postal_code, venue_country_code from events where base_price_amount is not null and base_price_amount > 0 and id = $1
`

func (q *Queries) GetPaidEventById(ctx context.Context, id uuid.UUID) (*Event, error) {
	row := q.db.QueryRow(ctx, getPaidEventById, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.TitleEn,
		&i.TitlePl,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsVirtual,
		&i.DescriptionEn,
		&i.DescriptionPl,
		&i.EventType,
		&i.BasePriceAmount,
		&i.BasePriceCurrency,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.SubtitleEn,
		&i.SubtitlePl,
		&i.VenueNameEn,
		&i.VenueNamePl,
		&i.VenueStreet,
		&i.VenueCityEn,
		&i.VenueCityPl,
		&i.VenuePostalCode,
		&i.VenueCountryCode,
	)
	return &i, err
}

const listEventRegistrationsForUserForEvents = `-- name: ListEventRegistrationsForUserForEvents :many
select er.id, er.event_id, er.user_id, er.inserted_at from event_registrations er
where er.event_id = any($1::uuid[])
and er.user_id = $2::uuid
`

type ListEventRegistrationsForUserForEventsParams struct {
	Eventids []uuid.UUID `json:"eventids"`
	Userid   uuid.UUID   `json:"userid"`
}

func (q *Queries) ListEventRegistrationsForUserForEvents(ctx context.Context, arg *ListEventRegistrationsForUserForEventsParams) ([]*EventRegistration, error) {
	rows, err := q.db.Query(ctx, listEventRegistrationsForUserForEvents, arg.Eventids, arg.Userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*EventRegistration
	for rows.Next() {
		var i EventRegistration
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.UserID,
			&i.InsertedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvents = `-- name: ListEvents :many
select e.id, e.slug, e.title_en, e.title_pl, e.is_virtual, e.base_price_amount, e.base_price_currency,
       e.event_type, e.starts_at, e.ends_at, e.subtitle_pl, e.subtitle_en,
       e.venue_street, e.venue_city_en, e.venue_city_pl, e.venue_country_code
from events e
order by e.starts_at desc
`

type ListEventsRow struct {
	ID                uuid.UUID        `json:"id"`
	Slug              string           `json:"slug"`
	TitleEn           string           `json:"titleEn"`
	TitlePl           string           `json:"titlePl"`
	IsVirtual         bool             `json:"isVirtual"`
	BasePriceAmount   *decimal.Decimal `json:"basePriceAmount"`
	BasePriceCurrency *string          `json:"basePriceCurrency"`
	EventType         EventType        `json:"eventType"`
	StartsAt          pgtype.Timestamp `json:"startsAt"`
	EndsAt            pgtype.Timestamp `json:"endsAt"`
	SubtitlePl        *string          `json:"subtitlePl"`
	SubtitleEn        *string          `json:"subtitleEn"`
	VenueStreet       *string          `json:"venueStreet"`
	VenueCityEn       *string          `json:"venueCityEn"`
	VenueCityPl       *string          `json:"venueCityPl"`
	VenueCountryCode  *string          `json:"venueCountryCode"`
}

func (q *Queries) ListEvents(ctx context.Context) ([]*ListEventsRow, error) {
	rows, err := q.db.Query(ctx, listEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListEventsRow
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.TitleEn,
			&i.TitlePl,
			&i.IsVirtual,
			&i.BasePriceAmount,
			&i.BasePriceCurrency,
			&i.EventType,
			&i.StartsAt,
			&i.EndsAt,
			&i.SubtitlePl,
			&i.SubtitleEn,
			&i.VenueStreet,
			&i.VenueCityEn,
			&i.VenueCityPl,
			&i.VenueCountryCode,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHostsForEvents = `-- name: ListHostsForEvents :many
select eh.event_id, h.id, h.salutation, h.given_name, h.family_name, h.profile_picture_id, h.inserted_at, h.updated_at, h.country, a.object_key profile_picture_url
from hosts h
join events_hosts eh on eh.host_id = h.id
left join assets a on h.profile_picture_id = a.id
where eh.event_id = any($1::uuid[])
order by eh.host_id, eh.position
`

type ListHostsForEventsRow struct {
	EventID           uuid.UUID        `json:"eventId"`
	ID                uuid.UUID        `json:"id"`
	Salutation        *string          `json:"salutation"`
	GivenName         string           `json:"givenName"`
	FamilyName        string           `json:"familyName"`
	ProfilePictureID  *uuid.UUID       `json:"profilePictureId"`
	InsertedAt        pgtype.Timestamp `json:"insertedAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	Country           *string          `json:"country"`
	ProfilePictureUrl *string          `json:"profilePictureUrl"`
}

func (q *Queries) ListHostsForEvents(ctx context.Context, eventids []uuid.UUID) ([]*ListHostsForEventsRow, error) {
	rows, err := q.db.Query(ctx, listHostsForEvents, eventids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListHostsForEventsRow
	for rows.Next() {
		var i ListHostsForEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.ID,
			&i.Salutation,
			&i.GivenName,
			&i.FamilyName,
			&i.ProfilePictureID,
			&i.InsertedAt,
			&i.UpdatedAt,
			&i.Country,
			&i.ProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPricesForEvents = `-- name: ListPricesForEvents :many
select p.id, p.event_id, p.price_type, p.rule_type, p.price_amount, p.price_currency, p.discount_code, p.priority, p.is_active, p.valid_from, p.valid_until, p.created_at, p.updated_at from event_prices p
where p.event_id = any($1::uuid[])
order by p.event_id, p.priority
`

func (q *Queries) ListPricesForEvents(ctx context.Context, eventids []uuid.UUID) ([]*EventPrice, error) {
	rows, err := q.db.Query(ctx, listPricesForEvents, eventids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*EventPrice
	for rows.Next() {
		var i EventPrice
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.PriceType,
			&i.RuleType,
			&i.PriceAmount,
			&i.PriceCurrency,
			&i.DiscountCode,
			&i.Priority,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
