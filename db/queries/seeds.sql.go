// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: seeds.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const upsertAsset = `-- name: UpsertAsset :one
insert into assets (id, object_key, original_filename) values ($1, $2, $3)
on conflict (id) do update set object_key = excluded.object_key, original_filename = excluded.original_filename, updated_at = now()
returning id, object_key, original_filename, inserted_at, updated_at
`

type UpsertAssetParams struct {
	ID               uuid.UUID `json:"id"`
	ObjectKey        string    `json:"objectKey"`
	OriginalFilename *string   `json:"originalFilename"`
}

func (q *Queries) UpsertAsset(ctx context.Context, arg *UpsertAssetParams) (*Asset, error) {
	row := q.db.QueryRow(ctx, upsertAsset, arg.ID, arg.ObjectKey, arg.OriginalFilename)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ObjectKey,
		&i.OriginalFilename,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const upsertEvent = `-- name: UpsertEvent :one
INSERT INTO events (id, event_type, title_en, title_pl, slug, starts_at, ends_at, is_virtual, description_en, description_pl, base_price_amount, base_price_currency, subtitle_en, subtitle_pl, venue_street, venue_city_en, venue_city_pl, venue_name_en, venue_name_pl, venue_country_code, venue_postal_code)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)
returning id, title_en, title_pl, starts_at, ends_at, is_virtual, description_en, description_pl, event_type, base_price_amount, base_price_currency, inserted_at, updated_at, slug, subtitle_en, subtitle_pl, venue_name_en, venue_name_pl, venue_street, venue_city_en, venue_city_pl, venue_postal_code, venue_country_code
`

type UpsertEventParams struct {
	ID                uuid.UUID        `json:"id"`
	EventType         EventType        `json:"eventType"`
	TitleEn           string           `json:"titleEn"`
	TitlePl           string           `json:"titlePl"`
	Slug              string           `json:"slug"`
	StartsAt          pgtype.Timestamp `json:"startsAt"`
	EndsAt            pgtype.Timestamp `json:"endsAt"`
	IsVirtual         bool             `json:"isVirtual"`
	DescriptionEn     string           `json:"descriptionEn"`
	DescriptionPl     *string          `json:"descriptionPl"`
	BasePriceAmount   *decimal.Decimal `json:"basePriceAmount"`
	BasePriceCurrency *string          `json:"basePriceCurrency"`
	SubtitleEn        *string          `json:"subtitleEn"`
	SubtitlePl        *string          `json:"subtitlePl"`
	VenueStreet       *string          `json:"venueStreet"`
	VenueCityEn       *string          `json:"venueCityEn"`
	VenueCityPl       *string          `json:"venueCityPl"`
	VenueNameEn       *string          `json:"venueNameEn"`
	VenueNamePl       *string          `json:"venueNamePl"`
	VenueCountryCode  *string          `json:"venueCountryCode"`
	VenuePostalCode   *string          `json:"venuePostalCode"`
}

func (q *Queries) UpsertEvent(ctx context.Context, arg *UpsertEventParams) (*Event, error) {
	row := q.db.QueryRow(ctx, upsertEvent,
		arg.ID,
		arg.EventType,
		arg.TitleEn,
		arg.TitlePl,
		arg.Slug,
		arg.StartsAt,
		arg.EndsAt,
		arg.IsVirtual,
		arg.DescriptionEn,
		arg.DescriptionPl,
		arg.BasePriceAmount,
		arg.BasePriceCurrency,
		arg.SubtitleEn,
		arg.SubtitlePl,
		arg.VenueStreet,
		arg.VenueCityEn,
		arg.VenueCityPl,
		arg.VenueNameEn,
		arg.VenueNamePl,
		arg.VenueCountryCode,
		arg.VenuePostalCode,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.TitleEn,
		&i.TitlePl,
		&i.StartsAt,
		&i.EndsAt,
		&i.IsVirtual,
		&i.DescriptionEn,
		&i.DescriptionPl,
		&i.EventType,
		&i.BasePriceAmount,
		&i.BasePriceCurrency,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.SubtitleEn,
		&i.SubtitlePl,
		&i.VenueNameEn,
		&i.VenueNamePl,
		&i.VenueStreet,
		&i.VenueCityEn,
		&i.VenueCityPl,
		&i.VenuePostalCode,
		&i.VenueCountryCode,
	)
	return &i, err
}

const upsertEventHost = `-- name: UpsertEventHost :one
INSERT INTO events_hosts (event_id, host_id, position)
VALUES ($1, $2, $3)
ON CONFLICT (event_id, host_id) DO UPDATE SET
    position = excluded.position,
    updated_at = now()
returning id, event_id, host_id, position, inserted_at, updated_at
`

type UpsertEventHostParams struct {
	EventID  uuid.UUID `json:"eventId"`
	HostID   uuid.UUID `json:"hostId"`
	Position int32     `json:"position"`
}

func (q *Queries) UpsertEventHost(ctx context.Context, arg *UpsertEventHostParams) (*EventsHost, error) {
	row := q.db.QueryRow(ctx, upsertEventHost, arg.EventID, arg.HostID, arg.Position)
	var i EventsHost
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.HostID,
		&i.Position,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const upsertEventPrice = `-- name: UpsertEventPrice :one
INSERT INTO event_prices (event_id, price_type, rule_type, price_amount, price_currency, discount_code, priority, is_active, valid_from, valid_until)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
on conflict do nothing
returning id, event_id, price_type, rule_type, price_amount, price_currency, discount_code, priority, is_active, valid_from, valid_until, created_at, updated_at
`

type UpsertEventPriceParams struct {
	EventID       uuid.UUID        `json:"eventId"`
	PriceType     PriceType        `json:"priceType"`
	RuleType      PriceRuleType    `json:"ruleType"`
	PriceAmount   decimal.Decimal  `json:"priceAmount"`
	PriceCurrency string           `json:"priceCurrency"`
	DiscountCode  *string          `json:"discountCode"`
	Priority      int32            `json:"priority"`
	IsActive      bool             `json:"isActive"`
	ValidFrom     pgtype.Timestamp `json:"validFrom"`
	ValidUntil    pgtype.Timestamp `json:"validUntil"`
}

func (q *Queries) UpsertEventPrice(ctx context.Context, arg *UpsertEventPriceParams) (*EventPrice, error) {
	row := q.db.QueryRow(ctx, upsertEventPrice,
		arg.EventID,
		arg.PriceType,
		arg.RuleType,
		arg.PriceAmount,
		arg.PriceCurrency,
		arg.DiscountCode,
		arg.Priority,
		arg.IsActive,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var i EventPrice
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.PriceType,
		&i.RuleType,
		&i.PriceAmount,
		&i.PriceCurrency,
		&i.DiscountCode,
		&i.Priority,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const upsertHost = `-- name: UpsertHost :one
INSERT INTO hosts (id, salutation, given_name, family_name, profile_picture_id, country)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (id) do nothing
returning id, salutation, given_name, family_name, profile_picture_id, inserted_at, updated_at, country
`

type UpsertHostParams struct {
	ID               uuid.UUID  `json:"id"`
	Salutation       *string    `json:"salutation"`
	GivenName        string     `json:"givenName"`
	FamilyName       string     `json:"familyName"`
	ProfilePictureID *uuid.UUID `json:"profilePictureId"`
	Country          *string    `json:"country"`
}

func (q *Queries) UpsertHost(ctx context.Context, arg *UpsertHostParams) (*Host, error) {
	row := q.db.QueryRow(ctx, upsertHost,
		arg.ID,
		arg.Salutation,
		arg.GivenName,
		arg.FamilyName,
		arg.ProfilePictureID,
		arg.Country,
	)
	var i Host
	err := row.Scan(
		&i.ID,
		&i.Salutation,
		&i.GivenName,
		&i.FamilyName,
		&i.ProfilePictureID,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.Country,
	)
	return &i, err
}

const upsertVideo = `-- name: UpsertVideo :one
INSERT INTO videos (id, event_id, provider, title_en, title_pl, slug, is_public)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (id) DO UPDATE SET
    event_id = excluded.event_id,
    provider = excluded.provider,
    title_en = excluded.title_en,
    title_pl = excluded.title_pl,
    slug = excluded.slug,
    is_public = excluded.is_public,
    updated_at = now()
returning id, provider, is_public, title_en, title_pl, slug, inserted_at, updated_at, event_id
`

type UpsertVideoParams struct {
	ID       uuid.UUID     `json:"id"`
	EventID  uuid.UUID     `json:"eventId"`
	Provider VideoProvider `json:"provider"`
	TitleEn  string        `json:"titleEn"`
	TitlePl  string        `json:"titlePl"`
	Slug     string        `json:"slug"`
	IsPublic bool          `json:"isPublic"`
}

func (q *Queries) UpsertVideo(ctx context.Context, arg *UpsertVideoParams) (*Video, error) {
	row := q.db.QueryRow(ctx, upsertVideo,
		arg.ID,
		arg.EventID,
		arg.Provider,
		arg.TitleEn,
		arg.TitlePl,
		arg.Slug,
		arg.IsPublic,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.IsPublic,
		&i.TitleEn,
		&i.TitlePl,
		&i.Slug,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.EventID,
	)
	return &i, err
}

const upsertVideoSource = `-- name: UpsertVideoSource :one
INSERT INTO video_sources (id, video_id, content_type, codec, object_key)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET
    video_id = excluded.video_id,
    content_type = excluded.content_type,
    codec = excluded.codec,
    object_key = excluded.object_key,
    updated_at = now()
returning id, content_type, codec, video_id, object_key, inserted_at, updated_at
`

type UpsertVideoSourceParams struct {
	ID          uuid.UUID `json:"id"`
	VideoID     uuid.UUID `json:"videoId"`
	ContentType string    `json:"contentType"`
	Codec       *string   `json:"codec"`
	ObjectKey   string    `json:"objectKey"`
}

func (q *Queries) UpsertVideoSource(ctx context.Context, arg *UpsertVideoSourceParams) (*VideoSource, error) {
	row := q.db.QueryRow(ctx, upsertVideoSource,
		arg.ID,
		arg.VideoID,
		arg.ContentType,
		arg.Codec,
		arg.ObjectKey,
	)
	var i VideoSource
	err := row.Scan(
		&i.ID,
		&i.ContentType,
		&i.Codec,
		&i.VideoID,
		&i.ObjectKey,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
