// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: event_registrations.sql

package queries

import (
	"context"

	sqlcrypter "github.com/bincyber/go-sqlcrypter"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRegistrationsForEvents = `-- name: CountRegistrationsForEvents :many
select er.event_id, count(er.id) from event_registrations er
where er.event_id = any($1::uuid[])
group by 1
`

type CountRegistrationsForEventsRow struct {
	EventID pgtype.UUID `json:"eventId"`
	Count   int64       `json:"count"`
}

func (q *Queries) CountRegistrationsForEvents(ctx context.Context, eventids []pgtype.UUID) ([]*CountRegistrationsForEventsRow, error) {
	rows, err := q.db.Query(ctx, countRegistrationsForEvents, eventids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*CountRegistrationsForEventsRow
	for rows.Next() {
		var i CountRegistrationsForEventsRow
		if err := rows.Scan(&i.EventID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastEventRegistration = `-- name: GetLastEventRegistration :one
select id, event_id, user_id, attending_in_person, is_host, inserted_at, updated_at, given_name_encrypted, family_name_encrypted, email_encrypted, country, email_confirmed_at, licence_number_encrypted from event_registrations order by id desc limit 1
`

// Only for testing
func (q *Queries) GetLastEventRegistration(ctx context.Context) (*EventRegistration, error) {
	row := q.db.QueryRow(ctx, getLastEventRegistration)
	var i EventRegistration
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.UserID,
		&i.AttendingInPerson,
		&i.IsHost,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.GivenName,
		&i.FamilyName,
		&i.Email,
		&i.Country,
		&i.EmailConfirmedAt,
		&i.LicenceNumber,
	)
	return &i, err
}

const insertEventRegistration = `-- name: InsertEventRegistration :one
insert into event_registrations (event_id, user_id, is_host, given_name_encrypted, family_name_encrypted, email_encrypted, country, attending_in_person, email_confirmed_at)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning id, event_id, user_id, attending_in_person, is_host, inserted_at, updated_at, given_name_encrypted, family_name_encrypted, email_encrypted, country, email_confirmed_at, licence_number_encrypted
`

type InsertEventRegistrationParams struct {
	EventID           pgtype.UUID               `json:"eventId"`
	UserID            pgtype.UUID               `json:"userId"`
	IsHost            bool                      `json:"isHost"`
	GivenName         sqlcrypter.EncryptedBytes `json:"givenNameEncrypted"`
	FamilyName        sqlcrypter.EncryptedBytes `json:"familyNameEncrypted"`
	Email             sqlcrypter.EncryptedBytes `json:"emailEncrypted"`
	Country           string                    `json:"country"`
	AttendingInPerson bool                      `json:"attendingInPerson"`
	EmailConfirmedAt  pgtype.Timestamp          `json:"emailConfirmedAt"`
}

func (q *Queries) InsertEventRegistration(ctx context.Context, arg *InsertEventRegistrationParams) (*EventRegistration, error) {
	row := q.db.QueryRow(ctx, insertEventRegistration,
		arg.EventID,
		arg.UserID,
		arg.IsHost,
		arg.GivenName,
		arg.FamilyName,
		arg.Email,
		arg.Country,
		arg.AttendingInPerson,
		arg.EmailConfirmedAt,
	)
	var i EventRegistration
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.UserID,
		&i.AttendingInPerson,
		&i.IsHost,
		&i.InsertedAt,
		&i.UpdatedAt,
		&i.GivenName,
		&i.FamilyName,
		&i.Email,
		&i.Country,
		&i.EmailConfirmedAt,
		&i.LicenceNumber,
	)
	return &i, err
}
