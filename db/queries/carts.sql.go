// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: carts.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const countCartLineItemQuantitiesForEvents = `-- name: CountCartLineItemQuantitiesForEvents :many
select c.event_id, c.quantity
from cart_line_items c
where c.event_id = any($1::uuid[]) and c.cart_id = $2::uuid
`

type CountCartLineItemQuantitiesForEventsParams struct {
	EventIds []uuid.UUID `json:"eventIds"`
	CartID   uuid.UUID   `json:"cartId"`
}

type CountCartLineItemQuantitiesForEventsRow struct {
	EventID  uuid.UUID `json:"eventId"`
	Quantity int32     `json:"quantity"`
}

func (q *Queries) CountCartLineItemQuantitiesForEvents(ctx context.Context, arg *CountCartLineItemQuantitiesForEventsParams) ([]*CountCartLineItemQuantitiesForEventsRow, error) {
	rows, err := q.db.Query(ctx, countCartLineItemQuantitiesForEvents, arg.EventIds, arg.CartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*CountCartLineItemQuantitiesForEventsRow
	for rows.Next() {
		var i CountCartLineItemQuantitiesForEventsRow
		if err := rows.Scan(&i.EventID, &i.Quantity); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCart = `-- name: GetCart :one
select cli.cart_id, count(cli.id) item_count, sum(cli.quantity * e.base_price_amount)::decimal product_total
from cart_line_items cli
join events e on cli.event_id = e.id
where cli.cart_id = $1::uuid 
group by 1
`

type GetCartRow struct {
	CartID       uuid.UUID       `json:"cartId"`
	ItemCount    int64           `json:"itemCount"`
	ProductTotal decimal.Decimal `json:"productTotal"`
}

func (q *Queries) GetCart(ctx context.Context, cartID uuid.UUID) (*GetCartRow, error) {
	row := q.db.QueryRow(ctx, getCart, cartID)
	var i GetCartRow
	err := row.Scan(&i.CartID, &i.ItemCount, &i.ProductTotal)
	return &i, err
}

const getCartItemsByCartId = `-- name: GetCartItemsByCartId :many
select c.id, c.cart_id, c.event_id, c.quantity, c.inserted_at, c.updated_at, e.id, e.title_en, e.title_pl, e.starts_at, e.ends_at, e.is_virtual, e.description_en, e.description_pl, e.event_type, e.base_price_amount, e.base_price_currency, e.inserted_at, e.updated_at, e.slug, e.subtitle_en, e.subtitle_pl, e.venue_name_en, e.venue_name_pl, e.venue_street, e.venue_city_en, e.venue_city_pl, e.venue_postal_code, e.venue_country_code, (e.base_price_amount * c.quantity)::decimal as subtotal
from cart_line_items c
join events e on c.event_id = e.id
where c.cart_id = $1::uuid
`

type GetCartItemsByCartIdRow struct {
	CartLineItem CartLineItem    `json:"cartLineItem"`
	Event        Event           `json:"event"`
	Subtotal     decimal.Decimal `json:"subtotal"`
}

func (q *Queries) GetCartItemsByCartId(ctx context.Context, cartID uuid.UUID) ([]*GetCartItemsByCartIdRow, error) {
	rows, err := q.db.Query(ctx, getCartItemsByCartId, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCartItemsByCartIdRow
	for rows.Next() {
		var i GetCartItemsByCartIdRow
		if err := rows.Scan(
			&i.CartLineItem.ID,
			&i.CartLineItem.CartID,
			&i.CartLineItem.EventID,
			&i.CartLineItem.Quantity,
			&i.CartLineItem.InsertedAt,
			&i.CartLineItem.UpdatedAt,
			&i.Event.ID,
			&i.Event.TitleEn,
			&i.Event.TitlePl,
			&i.Event.StartsAt,
			&i.Event.EndsAt,
			&i.Event.IsVirtual,
			&i.Event.DescriptionEn,
			&i.Event.DescriptionPl,
			&i.Event.EventType,
			&i.Event.BasePriceAmount,
			&i.Event.BasePriceCurrency,
			&i.Event.InsertedAt,
			&i.Event.UpdatedAt,
			&i.Event.Slug,
			&i.Event.SubtitleEn,
			&i.Event.SubtitlePl,
			&i.Event.VenueNameEn,
			&i.Event.VenueNamePl,
			&i.Event.VenueStreet,
			&i.Event.VenueCityEn,
			&i.Event.VenueCityPl,
			&i.Event.VenuePostalCode,
			&i.Event.VenueCountryCode,
			&i.Subtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCartLineItem = `-- name: InsertCartLineItem :one
insert into cart_line_items as cli (cart_id, event_id, quantity) values ($1, $2, 1) on conflict (cart_id, event_id)
do update set quantity = cli.quantity + excluded.quantity returning id, cart_id, event_id, quantity, inserted_at, updated_at
`

type InsertCartLineItemParams struct {
	CartID  uuid.UUID `json:"cartId"`
	EventID uuid.UUID `json:"eventId"`
}

func (q *Queries) InsertCartLineItem(ctx context.Context, arg *InsertCartLineItemParams) (*CartLineItem, error) {
	row := q.db.QueryRow(ctx, insertCartLineItem, arg.CartID, arg.EventID)
	var i CartLineItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.EventID,
		&i.Quantity,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
